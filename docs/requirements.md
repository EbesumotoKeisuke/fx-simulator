# 要件定義書

## 1. プロジェクト概要

### 1.1 プロジェクト名
FX Trade Simulator（FXトレードシミュレーター）

### 1.2 概要説明
実際のFX市場に近い環境でトレードの練習ができるシミュレーションツール。過去の為替データを使用してリアルな相場環境を再現し、仮想資金でトレードを行うことで、リスクなくトレードスキルを磨くことができる。

### 1.3 目的・背景
- **目的**: ユーザーのFXトレードスキル向上を支援する
- **背景**: 実際の資金を使わずにトレード経験を積むことで、リスク管理や相場分析のスキルを安全に習得したい

## 2. ユーザー定義

### 2.1 想定ユーザー
- 個人利用（開発者本人のみ）
- FXトレードの練習・スキル向上を目指す個人トレーダー

### 2.2 ユーザーの課題・ニーズ
| 課題 | ニーズ |
|------|--------|
| 実資金でのトレードはリスクが高い | リスクなしで練習したい |
| 過去の相場で自分の判断を検証したい | 過去データでのバックテスト機能 |
| トレードの記録・分析が手間 | 自動で履歴を記録し分析したい |
| 感情的なトレードを減らしたい | 客観的なパフォーマンス指標の確認 |

## 3. 機能要件

### 3.1 必須機能（MVP）
| 機能ID | 機能名 | 説明 | 優先度 |
|--------|--------|------|--------|
| F-001 | マルチタイムフレームチャート表示 | 日足・1時間足・10分足のローソク足チャートを同時表示。各時間足の最新時刻は同期して一致すること。各タイムフレームは境界を跨いだ時のみ更新し、高速再生時でも点滅しない | 高 |
| F-002 | 過去データ再生 | 過去の為替データを時系列で再生（早送り・一時停止可能）。一時停止ボタンを押した瞬間にチャート更新が即座に停止すること | 高 |
| F-003 | 注文機能 | 成行注文（買い/売り）の発注 | 高 |
| F-004 | ポジション管理 | 保有中のポジション一覧表示・決済。ロットサイズ、購入価格（エントリー価格）を表示 | 高 |
| F-005 | 損益計算 | リアルタイムの含み損益・確定損益の計算・表示 | 高 |
| F-006 | 仮想資金管理 | 初期資金の設定、残高管理 | 高 |
| F-007 | トレード履歴 | 過去のトレード履歴の記録・一覧表示 | 高 |
| F-008 | 為替データ読込 | ローカルフォルダに格納されたCSVファイル（日足・1時間足・10分足）から為替データを読み込む | 高 |

### 3.2 追加機能（あれば嬉しい）
| 機能ID | 機能名 | 説明 | 優先度 |
|--------|--------|------|--------|
| F-101 | 指値・逆指値注文 | 価格指定での予約注文（両方サポート、複数同時注文可能、キャンセル・変更可能） | 中 |
| F-102 | 損切り・利確設定 | ポジションごとのSL/TP設定（新規注文時・既存ポジション両方、価格・pips両対応、チャート表示） | 中 |
| F-103 | 複数通貨ペア対応 | USD/JPY以外の通貨ペアにも対応 | 中 |
| F-104 | テクニカル指標 | 移動平均線、RSI、MACD等の表示 | 中 |
| F-105 | パフォーマンス分析 | 勝率、プロフィットファクター、最大ドローダウン等の統計（専用分析画面 + メイン画面の簡易表示、グラフ表示） | 中 |
| F-106 | トレードメモ | 各トレードにメモ・振り返りを記録 | 低 |
| F-107 | 再生速度調整 | チャート再生速度の細かい調整（0.5x〜10x） | 低 |
| F-108 | シミュレーション開始日時指定 | 任意の日時からシミュレーションを開始できる | 中 |
| F-109 | シミュレーション終了・CSV出力 | 終了ボタンでシミュレーションを終了し、トレード履歴をCSVファイルとして出力。終了時に保有中の全ポジションを自動決済し、最終損益を確定する | 中 |
| F-110 | 統合画面レイアウト | 日足・1時間足・10分足チャートとトレード操作パネル（注文・ポジション管理）を1画面に同時表示 | 高 |
| F-111 | 外部データソース取込 | 外部の無料データソースから過去の為替データを取得し、ローカルCSVファイルに追記・更新する | 中 |

## 4. 非機能要件

### 4.1 性能要件
- チャートの描画はスムーズに動作すること（60fps目標）
- 過去データの読み込みは5秒以内
- 注文処理は即座に反映されること

### 4.2 セキュリティ要件
- 個人利用のため、認証機能は不要
- ローカル環境での動作を前提

### 4.3 可用性要件
- ローカル環境で安定して動作すること
- データの永続化（ブラウザを閉じてもトレード履歴が保持される）

### 4.4 保守性要件
- コードは可読性を重視
- 機能追加が容易な設計

## 5. 制約条件

### 5.1 技術的制約
- バックエンド: Python（FastAPI）
- フロントエンド: React（TypeScript）
- データベース: PostgreSQL
- 開発環境: Docker
- 為替データ:
  - ユーザーが用意したCSVファイル（日足・1時間足・10分足）をローカルフォルダに格納
  - 不足データは外部の無料データソース（例: Yahoo Finance API等）から取得可能

### 5.2 スケジュール制約
- 特になし（個人プロジェクト）

### 5.3 その他制約
- 実際の取引所との接続は行わない（シミュレーションのみ）
- リアルタイムデータ配信は行わない（過去データの再生のみ）

## 6. 用語定義
| 用語 | 説明 |
|------|------|
| ポジション | 保有中の通貨の持ち高（買いまたは売りの状態） |
| 成行注文 | 現在の市場価格で即座に約定する注文 |
| 指値注文 | 指定した価格に達したら約定する予約注文 |
| 逆指値注文 | 指定した価格に達したら成行で約定する予約注文 |
| SL（ストップロス） | 損切りライン。損失を限定するための決済価格 |
| TP（テイクプロフィット） | 利確ライン。利益を確定するための決済価格 |
| pips | 為替レートの最小変動単位（USD/JPYの場合0.01円） |
| ロット | 取引数量の単位（1ロット = 10万通貨が一般的） |
| スプレッド | 買値と売値の差額 |
| ドローダウン | 資産のピークからの下落幅 |
| プロフィットファクター | 総利益 ÷ 総損失 |

## 7. 前提条件・依存関係
- ユーザーが為替データCSVファイル（日足・1時間足・10分足）を用意し、所定のフォルダに格納すること
- CSVファイルのフォーマット: 日時, 始値, 高値, 安値, 終値, 出来高（OHLCV形式）
- Docker環境が利用可能であること
- モダンブラウザ（Chrome, Firefox, Edge等）で動作
- 外部データソース利用時はインターネット接続が必要

## 8. 追加機能の詳細仕様

### 8.1 F-101: 指値・逆指値注文

#### 概要
現在の成行注文に加えて、指値注文（Limit Order）と逆指値注文（Stop Order）の機能を追加する。トレーダーが特定の価格に達したときに自動的に注文を執行できるようにする。

#### 機能詳細
- **対応注文タイプ**:
  - 指値注文（Limit Order）: 指定価格以下で買い、または指定価格以上で売り
  - 逆指値注文（Stop Order）: 指定価格以上で買い、または指定価格以下で売り
- **複数注文**: 同時に複数の予約注文を保持可能
- **注文管理**:
  - 注文のキャンセル: 未約定の注文を削除可能
  - 注文の変更: 価格やロットサイズの変更可能
- **注文の有効期限**: 実装しない（手動キャンセルまで有効）
- **シミュレーション状態との関係**:
  - 一時停止時: 未約定注文はそのまま保持
  - 終了時: 未約定注文は全てキャンセル
- **約定ロジック**:
  - 10分足のローソク足OHLC（始値・高値・安値・終値）のいずれかが注文価格に達したときに約定
  - 約定価格は設定したトリガー価格
  - 約定後は通常のポジションとして管理
- **通知**: 約定時の通知機能は実装しない

#### UI設計
- **注文入力パネル**:
  - 場所: コントロールバーの下部または専用エリア
  - 入力項目: 注文タイプ（指値/逆指値）、売買方向（買/売）、ロットサイズ、トリガー価格
  - 操作: 注文ボタンで予約注文を作成
- **未約定注文一覧**:
  - 場所: ポジション一覧と口座情報の間
  - 表示項目: 注文タイプ、売買方向、ロットサイズ、トリガー価格、作成日時
  - 操作: 各注文に対してキャンセルボタン、変更ボタン
- **チャート表示**:
  - 10分足チャートに未約定注文の価格ラインを表示（オプション）
  - 指値注文: 青色ライン
  - 逆指値注文: オレンジ色ライン

---

### 8.2 F-102: 損切り・利確設定（SL/TP）

#### 概要
ポジションごとに損切り（Stop Loss）と利確（Take Profit）を設定できる機能。リスク管理と利益確定を自動化する。

#### 機能詳細
- **設定タイミング**:
  - 新規注文時: 成行注文・予約注文の作成時に同時設定
  - 既存ポジション: 保有中のポジションに後から追加・変更
- **設定方法**:
  - 価格指定: 具体的な価格を指定（例: 145.50円）
  - pips指定: エントリー価格からのpips数で指定（例: -20pips、+30pips）
  - 両方の指定方法をサポート
- **チャート表示**:
  - 10分足チャートにSL/TPのラインを表示
  - SLライン: 赤色の破線
  - TPライン: 緑色の破線
  - ポジションごとに対応するラインを表示
- **判定タイミング**:
  - 10分足のローソク足OHLC（始値・高値・安値・終値）のいずれかが基準を満たしたとき
  - チェックタイミング: シミュレーション時刻が更新されるたび
- **同時発動時の処理**:
  - 同一ローソク足でSLとTPの両方が満たされた場合、ユーザーに確認を求める
  - モーダル表示: 「損切りと利確の両方が達成されました。どちらを優先しますか？」
  - ユーザー選択: 損切り優先 / 利確優先
- **トレーリングストップ**: 実装しない（次フェーズで検討）

#### UI設計
- **注文入力パネル**:
  - SL設定: チェックボックス + 価格入力 / pips入力
  - TP設定: チェックボックス + 価格入力 / pips入力
  - 切替: 価格/pipsの切替ボタン
- **ポジション一覧**:
  - 表示項目追加: SL価格、TP価格
  - 操作: 各ポジションに「SL/TP設定」ボタン
- **SL/TP設定モーダル**:
  - 既存ポジションに対してSL/TPを設定・変更
  - 入力項目: SL（価格 or pips）、TP（価格 or pips）
  - プレビュー: 現在価格とSL/TPの位置関係を表示
- **同時発動確認モーダル**:
  - メッセージ: 同一ローソク足でSLとTPの両方が達成
  - ボタン: 「損切りを実行」「利確を実行」

---

### 8.3 F-105: パフォーマンス分析

#### 概要
シミュレーション結果を多角的に分析し、トレード成績を可視化する機能。トレーダーが自身のパフォーマンスを客観的に評価できるようにする。

#### 機能詳細
- **分析指標**:
  - **基本指標**:
    - 勝率（Win Rate）: 勝ちトレード数 / 総トレード数
    - 総損益（Total P&L）: 確定損益の合計
    - 総利益（Gross Profit）: 勝ちトレードの損益合計
    - 総損失（Gross Loss）: 負けトレードの損益合計
    - トレード回数（Total Trades）: 決済済みトレードの総数
  - **リスク・リターン指標**:
    - プロフィットファクター（Profit Factor）: 総利益 / 総損失
    - 平均利益（Average Win）: 総利益 / 勝ちトレード数
    - 平均損失（Average Loss）: 総損失 / 負けトレード数
    - リスクリワード比（Risk/Reward Ratio）: 平均利益 / 平均損失
    - 最大利益（Max Win）: 単一トレードの最大利益
    - 最大損失（Max Loss）: 単一トレードの最大損失
  - **ドローダウン指標**:
    - 最大ドローダウン（Max Drawdown）: 資産ピークからの最大下落額（円）
    - 最大ドローダウン率（Max Drawdown %）: 資産ピークからの最大下落率（%）
    - 最大ドローダウン期間（Max Drawdown Duration）: 最大ドローダウンの発生から回復までの期間
  - **連続性指標**:
    - 最大連勝数（Max Consecutive Wins）: 連続して勝ちトレードが続いた最大数
    - 最大連敗数（Max Consecutive Losses）: 連続して負けトレードが続いた最大数
  - **期間別指標**:
    - 日別損益: 日ごとの確定損益
    - 週別損益: 週ごとの確定損益
    - 月別損益: 月ごとの確定損益
- **グラフ表示**:
  - 資産曲線（Equity Curve）: 時系列での資産推移をライングラフで表示
  - 損益分布（P&L Distribution）: トレードごとの損益を棒グラフで表示
  - ドローダウングラフ: ドローダウンの推移を表示
  - 勝ち負け分布: 勝ちトレードと負けトレードの割合を円グラフで表示
- **比較機能**: 複数シミュレーション間の比較は次フェーズで実装

#### UI設計
- **メイン画面の簡易表示**:
  - 場所: 口座情報パネルの下部または右側
  - 表示項目: 勝率、プロフィットファクター、最大ドローダウン（主要3指標のみ）
  - サイズ: コンパクトなウィジェット形式
  - 操作: クリックで詳細分析画面（SCR-005）へ遷移
- **詳細分析画面（SCR-005）**:
  - レイアウト:
    - 上部: 主要指標カード（6〜8個）
    - 中央: 資産曲線グラフ（大きく表示）
    - 中下部: その他のグラフ（2〜3個を横並び）
    - 下部: 詳細統計 + プロからの改善コメント
  - 表示切替: 期間フィルター（全期間 / 直近1週間 / 直近1ヶ月）
  - エクスポート: 分析結果をPDFまたはCSVで出力（オプション）

#### AI改善コメント機能
- **概要**: ChatGPT APIまたはMCPサーバーを活用し、プロの為替トレーダー視点での改善提案を自動生成
- **入力データ**:
  - トレード履歴（全決済済みトレードの詳細）
  - 市場データ（CSVから取得した価格・テクニカル指標）
  - パフォーマンス指標（勝率、PF、DD等）
- **出力形式**:
  - 3〜5個の具体的な改善ポイント
  - 各ポイントには理由と具体的なアドバイスを含む
  - タイムスタンプ付きで最終更新日時を表示
- **実装方式**:
  - 方式1: ChatGPT API（OpenAI API）を直接呼び出し
  - 方式2: MCPサーバー経由でLLMと通信
  - どちらの方式でも実装可能な設計とする
- **プロンプト設計**:
  - ロール: 「あなたは経験豊富なプロの為替トレーダーです」
  - タスク: 「以下のトレードデータと市場環境を分析し、具体的な改善ポイントを3〜5個提案してください」
  - 出力形式: 番号付きリスト、各項目に理由と改善案を含む

---

## 9. 実装済み機能の今後の拡張

### 9.1 F-101: 指値・逆指値注文の拡張

**現在の実装状況**:
- ✓ バックエンドAPI完全実装（注文作成、変更、キャンセル、約定チェック）
- ✓ 単体テスト完了（8/8テスト成功）
- △ フロントエンドUI（基本的な実装のみ）

**今後の拡張機能**:
- チャート上に未約定注文の価格ラインを表示
  - 指値注文: 青色ライン
  - 逆指値注文: オレンジ色ライン
  - ドラッグで価格変更可能
- ✓ 注文パネルの改善（一部実装済み）
  - ✓ 現在価格との差分（pips）をリアルタイム表示（実装済み）
  - ワンクリック注文機能（未実装・実装不要）
- 注文履歴の詳細表示
  - 約定までの経過時間
  - 約定時の市場状況（ローソク足情報）

---

### 9.2 F-102: 損切り・利確設定（SL/TP）の拡張

**現在の実装状況**:
- ✓ バックエンドAPI完全実装（設定、判定、自動決済）
- ✓ 単体テスト完了（6/6テスト成功）
- ✓ フロントエンドUI完全実装（OrderPanel、PositionPanel）

**実装済み機能の詳細**:
- **OrderPanel（成行注文時のSL/TP設定）**:
  - チェックボックスでSL/TPを個別に有効/無効化
  - 価格指定とpips指定の切り替え機能
  - 成行注文時のみ表示（指値・逆指値注文時は非表示）
- **PositionPanel（既存ポジションのSL/TP設定）**:
  - ポジション一覧にSL/TPカラムを表示（価格またはpips）
  - 各ポジションに「SL/TP」ボタンを配置
  - モーダルでSL/TPを編集（チェックボックスで個別有効化）
  - 既存のSL/TP値がある場合は自動読み込み
- **バリデーション機能**:
  - 価格指定時：エントリー価格との大小関係をチェック
    - 買い：SL < エントリー価格、TP > エントリー価格
    - 売り：SL > エントリー価格、TP < エントリー価格
  - 条件違反時はエラーメッセージを表示し保存を防止
  - pips指定時：バックエンドで自動計算されるため、フロントエンドでのバリデーションは不要
- **✓ SL/TP設定のプリセット機能（実装済み）**:
  - OrderPanel（成行注文時）とPositionPanel（編集モーダル）に実装
  - pips指定モード時に4つのプリセットボタンを表示：-10, -20, -30, -50 pips
  - バックエンドの計算ロジック：
    - 買い：SL価格 = エントリー価格 + (sl_pips × 0.01)、TP価格 = エントリー価格 + (tp_pips × 0.01)
    - 売り：SL価格 = エントリー価格 - (sl_pips × 0.01)、TP価格 = エントリー価格 - (tp_pips × 0.01)
  - SLは常に負の値を使用（買い・売りともに）
  - TPは買いは正の値、売りは負の値を使用
  - ワンクリックで一般的なSL値を素早く設定可能
  - 位置：SL入力欄の横に配置（OrderPanel）、入力欄の下に配置（PositionPanel）
- **✓ 予約注文の現在価格との差分表示（実装済み）**:
  - 指値・逆指値注文時にトリガー価格入力欄の横にpips差分を表示
  - 計算式：(トリガー価格 - 現在価格) / 0.01
  - 表示形式：(+X.X pips) または (-X.X pips)
  - リアルタイム更新：トリガー価格を変更すると即座に再計算

**今後の拡張機能**:
- チャート上にSL/TPラインを表示
  - SLライン: 赤色の破線
  - TPライン: 緑色の破線
  - ドラッグで価格変更可能
- 同時発動時の確認モーダル
  - 同一ローソク足でSLとTPが両方達成された場合の処理選択
  - ユーザー選択: 損切り優先 / 利確優先
- トレーリングストップ機能
  - 価格が有利な方向に動いたときにSLを自動調整
  - トレーリング幅の設定（pips指定）

---

### 9.3 F-105: パフォーマンス分析の拡張

**現在の実装状況**:
- ✓ バックエンドAPI実装（基本指標、資産曲線、ドローダウン）
- ✓ 単体テスト完了（5/5テスト成功）
- ✓ フロントエンドUI実装完了（AccountInfo簡易表示、AnalysisPage詳細画面）

**実装済み機能の詳細**:
- **AccountInfo（簡易パフォーマンス表示）**:
  - 場所：メイン画面の口座情報パネル下部
  - 表示項目：
    - 取引回数（勝/負）
    - 勝率（50%以上で緑色表示）
    - プロフィットファクター（1.0以上で緑色、未満で赤色）
    - 最大ドローダウン（金額と%）
    - 最大連勝/連敗
  - 取引データがある場合のみ表示（total_trades > 0）
- **AnalysisPage（詳細分析画面）**:
  - ルーティング：/analysis パス
  - ヘッダーに「分析」ボタンを追加（idle状態では無効化）
  - レイアウト構成：
    - 主要指標カード（4つ）：勝率、PF、最大DD、トータル損益
    - リスク・リターン指標セクション：平均利益/損失、RR比、最大利益/損失、DD継続期間
    - 連続記録セクション：最大連勝/連敗
    - シミュレーション期間情報：開始日時、終了日時、期間
    - 資産曲線データテーブル（最新10件表示）
    - ドローダウンデータテーブル（最新10件表示）
  - データがない場合の適切なエラー表示

**今後の拡張機能**:
- 期間別指標の実装
  - 日別/週別/月別の損益集計
  - カレンダー形式での損益表示
- 資産曲線の時間・日単位集約
  - interval パラメータ（hour, day）の実装
  - データ量削減とパフォーマンス向上
- AI改善コメント機能
  - ChatGPT APIまたはMCPサーバーとの連携
  - トレード履歴と市場データを元にした改善提案
  - プロの為替トレーダー視点でのアドバイス生成
- 詳細分析画面（SCR-005）の実装
  - 主要指標カードの表示
  - 資産曲線、損益分布、ドローダウンの複合グラフ
  - トレード履歴との連動表示
- エクスポート機能
  - 分析結果のPDF出力
  - トレード履歴のCSV出力
- 複数シミュレーション間の比較機能
  - 異なる戦略の成績を並べて比較
  - ベンチマークとの比較

---

### 9.4 F-001: マルチタイムフレームチャート表示の改善（未来データ非表示対応）

#### 現状の問題点

**未来データが上位時間足で表示されてしまう問題**:
- 各時間足（W1, D1, H1, M10）のデータは、完全なOHLCとしてDBに保存されている
- 例：1時間足の12:00台のローソク足は、12:00〜12:59の全データを含む完全なOHLCとして保存
- `currentTime`が12/30 12:30の場合でも、1時間足の12:00台のローソク足全体（12:00〜12:59の全OHLC）が表示される
- これにより、10分足でまだ表示されていない未来のデータ（12:40、12:50）のOHLCを1時間足のローソク足から予測できてしまう
- 日足・週足でも同様の問題が発生し、リアルなトレード環境とは乖離している

**具体例**:
```
現在時刻: 2024/12/30 12:30

【10分足】
- 12:30までのローソク足を表示 ✓

【1時間足】
- 11:00台までのローソク足: 完全なOHLC（11:00〜11:59の全データ） ✓
- 12:00台のローソク足: 12:00〜12:59の全データのOHLC ✗（12:40、12:50の未来データを含む）
  → 本来は12:00〜12:30のみのOHLCを表示すべき

【日足】
- 12/29以前のローソク足: 完全なOHLC ✓
- 12/30のローソク足: 7:00〜翌6:59の全データのOHLC ✗（13:00以降の未来データを含む）
  → 本来は7:00〜12:30のみのOHLCを表示すべき

【週足】
- 前週以前のローソク足: 完全なOHLC ✓
- 今週のローソク足: 週の開始〜週の終了までの全データのOHLC ✗（12/31以降の未来データを含む）
  → 本来は週の開始〜12/30 12:30のみのOHLCを表示すべき
```

#### 修正方針

**基本コンセプト**:
- 10分足で表示されている時間より未来の日付・時間の内容は、他の時間足でも表示しない
- 各時間足で、**最新のローソク足のみを`currentTime`までのデータで動的に生成**する
- 過去の完成したローソク足（最新以外）はそのまま表示して良い

**修正対象**:
1. **1時間足（H1）**:
   - 最新以外のローソク足: DBに保存された完全なOHLCをそのまま表示
   - 最新のローソク足: `currentTime`を含む時間帯（例：12:00台）の開始時刻〜`currentTime`までの10分足データを集約してOHLCを計算
   - 10分足が更新されたら（例：12:40、12:50）、最新のローソク足を再計算して更新

2. **日足（D1）**:
   - 最新以外のローソク足: DBに保存された完全なOHLCをそのまま表示
   - 最新のローソク足: `currentTime`を含む日の開始時刻（7:00）〜`currentTime`までの10分足または1時間足データを集約してOHLCを計算
   - 時間が進むごとに最新のローソク足を再計算して更新

3. **週足（W1）**:
   - 最新以外のローソク足: DBに保存された完全なOHLCをそのまま表示
   - 最新のローソク足: `currentTime`を含む週の開始時刻〜`currentTime`までの日足または10分足データを集約してOHLCを計算
   - 日が進むごとに最新のローソク足を再計算して更新

#### 実装方針

**バックエンド実装**:

1. **新しいAPIエンドポイントまたは既存APIの拡張**:
   - 既存の`/market-data/candles/before` APIを拡張、または新しいエンドポイント`/market-data/candles/partial`を作成
   - パラメータ: `timeframe`, `before_time`（currentTime）, `limit`
   - 戻り値: ローソク足リスト（最新のローソク足は動的生成されたもの）

2. **最新ローソク足の動的生成ロジック**:
   ```python
   def get_candles_with_partial_last(timeframe, current_time, limit):
       # 1. 最新のローソク足の開始時刻を計算
       latest_candle_start = calculate_candle_start_time(timeframe, current_time)

       # 2. 最新以外のローソク足を取得（latest_candle_start より前のデータ）
       completed_candles = get_completed_candles(timeframe, latest_candle_start, limit - 1)

       # 3. 最新のローソク足を元データ（10分足または日足）から動的生成
       partial_candle = generate_partial_candle(timeframe, latest_candle_start, current_time)

       # 4. 完成済みローソク足 + 最新のローソク足を結合して返す
       return completed_candles + [partial_candle]

   def generate_partial_candle(timeframe, start_time, current_time):
       # 4-1. 集約元の時間足を決定
       source_timeframe = get_source_timeframe(timeframe)
       # H1 → M10（10分足）
       # D1 → M10 または H1（10分足または1時間足）
       # W1 → D1 または M10（日足または10分足）

       # 4-2. start_time 〜 current_time の元データを取得
       source_candles = get_candles(source_timeframe, start_time, current_time)

       # 4-3. OHLCを計算
       if not source_candles:
           return None

       return {
           'timestamp': start_time,
           'open': source_candles[0].open,          # 最初のデータの始値
           'high': max(c.high for c in source_candles),  # 全データの高値の最大値
           'low': min(c.low for c in source_candles),    # 全データの安値の最小値
           'close': source_candles[-1].close,       # 最後のデータの終値
           'volume': sum(c.volume for c in source_candles)  # 全データの出来高の合計
       }

   def calculate_candle_start_time(timeframe, current_time):
       # 各時間足に応じてローソク足の開始時刻を計算
       if timeframe == 'H1':
           # 現在時刻の「時」の開始時刻（例：12:30 → 12:00）
           return current_time.replace(minute=0, second=0, microsecond=0)
       elif timeframe == 'D1':
           # 現在日の開始時刻（7:00）
           day_start = current_time.replace(hour=7, minute=0, second=0, microsecond=0)
           if current_time.hour < 7:
               # 7:00より前の場合は前日の7:00
               day_start -= timedelta(days=1)
           return day_start
       elif timeframe == 'W1':
           # 現在週の開始時刻（月曜日7:00）
           # ISO週定義: 月曜日を週の開始とする
           days_since_monday = current_time.weekday()  # 月曜=0, 日曜=6
           week_start = current_time - timedelta(days=days_since_monday)
           week_start = week_start.replace(hour=7, minute=0, second=0, microsecond=0)
           if current_time.weekday() == 0 and current_time.hour < 7:
               # 月曜日の7:00より前の場合は前週の月曜日7:00
               week_start -= timedelta(days=7)
           return week_start
   ```

3. **集約元時間足の選択基準**:
   - **1時間足（H1）**: 10分足（M10）から集約（6本で1時間）
   - **日足（D1）**:
     - オプション1: 10分足（M10）から集約（144本で1日、ただし7:00〜翌6:59）
     - オプション2: 1時間足（H1）から集約（24本で1日、より効率的）
     - 推奨: 1時間足（H1）から集約（パフォーマンスとデータ精度のバランスが良い）
   - **週足（W1）**:
     - オプション1: 日足（D1）から集約（7本で1週間、最も効率的）
     - オプション2: 1時間足（H1）から集約（168本で1週間）
     - 推奨: 日足（D1）から集約（最も効率的）

**フロントエンド実装**:

1. **API呼び出しの変更**:
   - `ChartPanel.tsx`の`fetchData()`メソッドで、新しいAPI（`/market-data/candles/partial`）を呼び出す
   - または既存の`getCandlesBefore`のレスポンスが動的生成されたデータを含むことを想定

2. **チャート更新ロジック**:
   - 現在の`shouldUpdateCandle()`ロジックはそのまま使用可能
   - ローソク足境界を跨いだときだけ再取得するため、過剰なリクエストは発生しない
   - 最新のローソク足はバックエンドで動的生成されるため、フロントエンド側での特別な処理は不要

3. **パフォーマンス最適化**:
   - 10分足が更新されるたびに上位時間足も再計算されるが、バックエンドでの集約処理は軽量
   - キャッシュ機構の導入（オプション）: 最新のローソク足を一定時間キャッシュして、同じ`currentTime`での重複計算を避ける

#### 期待される効果

1. **リアルなトレード環境の再現**:
   - 上位時間足から未来のデータを予測できなくなる
   - 実際のトレード環境により近いシミュレーションが可能

2. **トレードスキル向上への貢献**:
   - 未来データを見ることなく、純粋に現在までのデータのみで判断を下す練習ができる
   - マルチタイムフレーム分析の精度が向上

3. **システムの整合性向上**:
   - 全ての時間足で同じ時刻までのデータのみが表示される
   - ユーザーの信頼性が向上

#### 実装上の注意点

1. **週足・日足の開始時刻定義**:
   - 日足: 7:00（FX市場の一般的な日次開始時刻、東京市場開始時刻）
   - 週足: 月曜日7:00（ISO週定義に準拠）
   - CSVデータの時刻定義と整合性を取る必要がある

2. **データの連続性**:
   - 元データ（10分足や1時間足）に欠損がある場合、最新のローソク足が正しく生成されない可能性
   - エラーハンドリング: 元データが0件の場合は最新のローソク足を生成しない

3. **境界時刻の扱い**:
   - `currentTime`がちょうど境界時刻（例：12:00:00）の場合の扱いを明確にする
   - 推奨: 境界時刻は新しいローソク足の開始とみなす（12:00:00は12:00台の開始）

4. **パフォーマンス**:
   - 10分足が更新されるたびに上位時間足の最新ローソク足を再計算するため、計算量が増加
   - ただし、集約処理は軽量であり、通常のシミュレーション速度（1x〜10x）では問題ない
   - 必要に応じてキャッシュ機構を導入（現在時刻が変わらない限り同じ結果を返す）

#### テスト計画

1. **単体テスト**:
   - `calculate_candle_start_time()`: 各時間足の開始時刻計算が正しいか
   - `generate_partial_candle()`: OHLCの計算が正しいか
   - 境界条件: `currentTime`が境界時刻の場合、元データが0件の場合

2. **結合テスト**:
   - シミュレーション実行時に、各時間足の最新のローソク足が正しく更新されるか
   - 10分足が更新されたときに、1時間足・日足・週足の最新のローソク足も正しく更新されるか
   - 境界時刻を跨いだときに、新しいローソク足が正しく生成されるか

3. **UIテスト**:
   - チャート画面で、各時間足の最新のローソク足が`currentTime`までのデータのみを反映しているか目視確認
   - 10分足が12:30までの場合、1時間足の12:00台のローソク足の終値が12:30時点の価格と一致するか
   - シミュレーション速度を変更しても、正しく動作するか

---

### 9.5 F-002: リアルタイムローソク足更新機能

#### 現状の問題点

**上位時間足の更新タイミングの問題**:
- 現在の実装では、ローソク足の境界を跨いだときのみチャートデータを再取得している
- 1時間足は10分足が6本（60分）完成してから更新される
- 最新のローソク足が部分的に生成される仕組み（F-001）を実装したが、フロントエンドの更新ロジックが追従していない
- 結果として、10分足が1本更新されても、上位時間足（H1, D1, W1）の最新のローソク足がリアルタイムで更新されない

**具体例**:
```
現在時刻: 12:30（10分足が1本完成）

【期待される動作】
- 10分足: 12:30のローソク足が表示される ✓
- 1時間足: 12:00台のローソク足が12:00〜12:30のデータで更新される ✗（現状は12:00〜12:00のまま）
- 日足: 当日のローソク足が7:00〜12:30のデータで更新される ✗（現状は7:00〜12:20のまま）

現在時刻: 12:40（10分足がさらに1本完成）

【期待される動作】
- 10分足: 12:40のローソク足が表示される ✓
- 1時間足: 12:00台のローソク足が12:00〜12:40のデータで更新される ✗（現状は12:00〜12:30のまま）
- 日足: 当日のローソク足が7:00〜12:40のデータで更新される ✗（現状は12:00〜12:30のまま）
```

#### 修正方針

**基本コンセプト**:
- 10分足が1本更新されるたびに、上位時間足（H1, D1, W1）の最新のローソク足も更新する
- バックエンドの`get_candles_with_partial_last()`は既に部分的なローソク足を動的生成しているため、フロントエンドの更新ロジックのみ修正すればよい
- チャートの再取得を適切なタイミングで実行する

**修正対象**:

1. **ChartPanel.tsxの更新ロジック修正**:
   - `shouldUpdateCandle()`メソッドを修正、または削除
   - `currentTime`が変更されたら、常にチャートデータを再取得する
   - ただし、10分足の境界を跨いだときのみ再取得する（不要な再取得を避ける）

2. **パフォーマンス最適化**:
   - 10分足が更新されるたびに全時間足のチャートを再取得するため、APIリクエストが増加する
   - バックエンドでの部分的ローソク足生成は軽量なため、通常の速度（1x〜10x）では問題ない
   - 必要に応じて、レート制限やデバウンス処理を導入

#### 実装方針

**フロントエンド実装**:

1. **ChartPanel.tsxの修正**:
   ```typescript
   // Before: ローソク足の境界を跨いだときのみ更新
   const shouldUpdateCandle = (prevTime: Date | null, newTime: Date): boolean => {
     if (!prevTime) return true

     // 時間足に応じた境界判定
     switch (timeframe) {
       case 'M10':
         return prevTime.getHours() !== newTime.getHours() ||
                Math.floor(prevTime.getMinutes() / 10) !== Math.floor(newTime.getMinutes() / 10)
       case 'H1':
         return prevTime.getHours() !== newTime.getHours()
       case 'D1':
         return prevTime.getDate() !== newTime.getDate()
       case 'W1':
         return getISOWeek(prevTime) !== getISOWeek(newTime)
     }
   }

   // After: 10分足の境界を跨いだときに全時間足を更新
   const shouldUpdateCandle = (prevTime: Date | null, newTime: Date): boolean => {
     if (!prevTime) return true

     // 10分足の境界を跨いだかチェック（全時間足共通）
     return prevTime.getHours() !== newTime.getHours() ||
            Math.floor(prevTime.getMinutes() / 10) !== Math.floor(newTime.getMinutes() / 10)
   }
   ```

2. **useEffect依存関係の調整**:
   - `currentTime`が変更されたときに`shouldUpdateCandle()`をチェックし、trueなら`fetchData()`を実行
   - 全時間足で同じ更新タイミングを使用

#### 期待される効果

1. **リアルなトレード環境の再現**:
   - 10分足が更新されるたびに、上位時間足の最新のローソク足もリアルタイムで更新される
   - 実際のトレード環境に近い動的なチャート表示

2. **トレードスキル向上への貢献**:
   - 上位時間足の変化を即座に確認できる
   - マルチタイムフレーム分析の精度が向上

3. **ユーザー体験の向上**:
   - チャートが滑らかに更新される
   - 違和感のない自然な動作

#### 実装上の注意点

1. **パフォーマンス**:
   - 10分足が更新されるたびに全時間足のチャートを再取得するため、APIリクエストが増加
   - ただし、バックエンドの処理は軽量であり、通常のシミュレーション速度では問題ない
   - 高速再生（100x以上）では、必要に応じてレート制限を導入

2. **チャートのちらつき防止**:
   - 新しいデータが取得されるまで、古いデータを表示し続ける
   - lightweight-chartsの`update()`メソッドを使用して、滑らかに更新

#### テスト計画

1. **単体テスト**:
   - `shouldUpdateCandle()`が10分足の境界を正しく検出するか

2. **結合テスト**:
   - 10分足が1本更新されたときに、全時間足のチャートが再取得されるか
   - 各時間足の最新のローソク足が正しく更新されるか

3. **UIテスト**:
   - シミュレーション実行中に、上位時間足の最新のローソク足がリアルタイムで更新されるか目視確認
   - チャートがちらつかず、滑らかに更新されるか

---

### 9.6 F-003: パフォーマンス分析へのチャート表示機能

#### 現状の問題点

**視覚的な分析の欠如**:
- 現在のパフォーマンス分析画面には統計情報（勝率、損益、ドローダウンなど）のみが表示されている
- 売買履歴がどのような相場状況で発生したのか視覚的に確認できない
- エントリー・イグジットのタイミングが適切だったか判断しづらい
- トレードの改善点を見つけにくい

**具体例**:
```
【現状】
- 勝率: 65%
- 総損益: +15,000円
- 最大ドローダウン: -5,000円
→ この数値だけでは、どこで勝ち/負けたのか、どのような相場状況だったのか分からない

【期待される表示】
- チャート上にエントリー・イグジットポイントをマーカーで表示
- 買いエントリー: 緑の↑マーカー
- 売りエントリー: 赤の↓マーカー
- イグジット: ×マーカー
- 損益が一目で分かる表示（プラスは緑、マイナスは赤）
```

#### 修正方針

**基本コンセプト**:
- パフォーマンス分析画面にチャートを追加
- 売買履歴をチャート上に可視化
- チャートと統計情報を並べて表示し、総合的な分析を可能にする

**修正対象**:

1. **パフォーマンス分析画面のレイアウト変更**:
   - 上部: チャート（売買履歴マーカー付き）
   - 下部: 統計情報（既存の表示）

2. **売買履歴マーカーの表示**:
   - エントリーポイント: 矢印マーカー（買い=緑↑、売り=赤↓）
   - イグジットポイント: ×マーカー
   - 損益情報: マーカーホバー時にツールチップで表示

3. **チャートの時間範囲設定**:
   - 売買履歴の開始時刻〜終了時刻を自動的に表示
   - ユーザーが時間範囲を変更可能

4. **最低ローソク足表示本数の保証**:
   - 売買履歴が少ない場合でも、チャートとして機能するよう最低80本のローソク足を表示
   - 各時間足（週足・日足・1時間足・10分足）それぞれで最低80本を保証
   - 売買履歴の時間範囲内のローソク足数が80本未満の場合、範囲を過去方向に拡張して取得
   - これにより、上位時間足でも十分なローソク足が表示され、テクニカル分析が可能になる

#### 実装方針

**バックエンド実装**:

1. **新しいAPIエンドポイント（オプション）**:
   ```python
   @router.get("/simulation/{simulation_id}/trades-with-candles")
   async def get_trades_with_candles(
       simulation_id: int,
       timeframe: str = Query('H1', description="時間足"),
       min_candles: int = Query(80, description="最低ローソク足本数"),
       db: Session = Depends(get_db)
   ):
       """
       売買履歴とローソク足データを一緒に取得する
       min_candles: 最低限表示するローソク足の本数（デフォルト80本）
       """
       # 売買履歴を取得
       trades = get_trades(simulation_id, db)

       # 売買履歴の時間範囲を取得
       start_time = min(t.entry_time for t in trades)
       end_time = max(t.exit_time for t in trades if t.exit_time)

       # ローソク足データを取得（最低本数を保証）
       candles = get_candles_with_minimum(
           timeframe, start_time, end_time, min_candles=min_candles, limit=10000
       )

       return {
           'trades': trades,
           'candles': candles,
           'timeframe': timeframe,
           'start_time': start_time,
           'end_time': end_time
       }
   ```

**フロントエンド実装**:

1. **PerformanceAnalysisページの修正**:
   ```typescript
   // ChartPanelコンポーネントを追加
   import ChartPanel from './ChartPanel'

   // 売買履歴マーカーを追加
   const addTradeMarkers = (chart, trades) => {
     trades.forEach(trade => {
       // エントリーマーカー
       chart.addMarker({
         time: trade.entry_time,
         position: trade.type === 'buy' ? 'belowBar' : 'aboveBar',
         color: trade.type === 'buy' ? '#00ff00' : '#ff0000',
         shape: trade.type === 'buy' ? 'arrowUp' : 'arrowDown',
         text: `Entry: ${trade.entry_price}`
       })

       // イグジットマーカー
       if (trade.exit_time) {
         chart.addMarker({
           time: trade.exit_time,
           position: 'aboveBar',
           color: trade.profit > 0 ? '#00ff00' : '#ff0000',
           shape: 'circle',
           text: `Exit: ${trade.exit_price} (P/L: ${trade.profit})`
         })
       }
     })
   }
   ```

2. **レイアウト調整**:
   - Grid layoutで上部にチャート、下部に統計情報
   - チャートの高さは画面の50%程度
   - 時間足切り替えボタンを追加

#### 期待される効果

1. **視覚的な分析の実現**:
   - 売買履歴がどのような相場状況で発生したか一目で分かる
   - エントリー・イグジットのタイミングが適切だったか判断しやすい

2. **トレードスキル向上への貢献**:
   - 良いトレードと悪いトレードのパターンを視覚的に比較できる
   - 改善点を見つけやすい

3. **ユーザー体験の向上**:
   - 統計情報だけでなく、視覚的にも分析できる
   - より直感的な分析が可能

#### 実装上の注意点

1. **パフォーマンス**:
   - 売買履歴が多い場合、マーカーの描画に時間がかかる可能性
   - 必要に応じて、表示するマーカー数を制限

2. **チャートの時間範囲**:
   - 売買履歴の時間範囲が長い場合、チャートが見づらくなる可能性
   - ズーム・パン機能を提供

#### テスト計画

1. **UIテスト**:
   - チャートが正しく表示されるか
   - 売買履歴マーカーが正しい位置に表示されるか
   - マーカーホバー時にツールチップが表示されるか

---

### 9.7 F-004: 売買履歴のインポート・エクスポート機能

#### 現状の問題点

**売買履歴の永続化と再分析の欠如**:
- 現在のシミュレーターは、その場でトレードしてパフォーマンスを分析する仕組み
- シミュレーションを終了すると、売買履歴がデータベースから削除される（または残っても再利用できない）
- 過去のトレード結果を保存して、後で再分析できない
- 複数のシミュレーション結果を比較できない

**具体例**:
```
【現状】
1. シミュレーション実行 → トレード → パフォーマンス分析
2. 画面を閉じる → データが失われる（または再利用不可）
3. 後で見返したい → 再度シミュレーションを実行する必要がある

【期待される動作】
1. シミュレーション実行 → トレード → パフォーマンス分析
2. 売買履歴をエクスポート（CSV/JSON）
3. 後で売買履歴をインポート → パフォーマンス分析
4. 複数の売買履歴を比較分析
```

#### 修正方針

**基本コンセプト**:
- 売買履歴をCSV/JSON形式でエクスポートできる
- 過去の売買履歴をファイルからインポートできる
- インポートした履歴を元にパフォーマンス分析を実行できる
- 複数の売買履歴を比較分析できる（将来的な拡張）

**修正対象**:

1. **売買履歴のエクスポート機能**:
   - パフォーマンス分析画面に「エクスポート」ボタンを追加
   - CSV形式とJSON形式をサポート
   - ファイル名: `trades_YYYYMMDD_HHMMSS.csv` または `trades_YYYYMMDD_HHMMSS.json`

2. **売買履歴のインポート機能**:
   - パフォーマンス分析画面に「インポート」ボタンを追加
   - CSV/JSONファイルを選択してインポート
   - インポート後、パフォーマンス分析を実行

3. **売買履歴のデータフォーマット**:
   - CSV形式:
     ```csv
     trade_id,entry_time,entry_price,exit_time,exit_price,type,lots,profit,commission,swap,hold_time
     1,2025-01-15 10:00:00,145.50,2025-01-15 12:00:00,145.80,buy,0.1,300,0,0,7200
     2,2025-01-15 14:00:00,145.90,2025-01-15 16:00:00,145.60,sell,0.1,-300,0,0,7200
     ```
   - JSON形式:
     ```json
     {
       "simulation_info": {
         "start_time": "2025-01-15 09:00:00",
         "end_time": "2025-01-15 18:00:00",
         "initial_balance": 100000,
         "final_balance": 115000
       },
       "trades": [
         {
           "trade_id": 1,
           "entry_time": "2025-01-15 10:00:00",
           "entry_price": 145.50,
           "exit_time": "2025-01-15 12:00:00",
           "exit_price": 145.80,
           "type": "buy",
           "lots": 0.1,
           "profit": 300,
           "commission": 0,
           "swap": 0,
           "hold_time": 7200
         }
       ]
     }
     ```

#### 実装方針

**バックエンド実装**:

1. **新しいAPIエンドポイント**:
   ```python
   @router.get("/simulation/{simulation_id}/export")
   async def export_trades(
       simulation_id: int,
       format: str = Query('csv', description="エクスポート形式（csv/json）"),
       db: Session = Depends(get_db)
   ):
       """
       売買履歴をエクスポートする
       """
       trades = get_trades(simulation_id, db)

       if format == 'csv':
           csv_data = generate_csv(trades)
           return Response(content=csv_data, media_type='text/csv',
                         headers={'Content-Disposition': f'attachment; filename=trades_{simulation_id}.csv'})
       elif format == 'json':
           json_data = generate_json(trades)
           return Response(content=json_data, media_type='application/json',
                         headers={'Content-Disposition': f'attachment; filename=trades_{simulation_id}.json'})

   @router.post("/simulation/import")
   async def import_trades(
       file: UploadFile,
       db: Session = Depends(get_db)
   ):
       """
       売買履歴をインポートする
       """
       # ファイルの拡張子をチェック
       if file.filename.endswith('.csv'):
           trades = parse_csv(await file.read())
       elif file.filename.endswith('.json'):
           trades = parse_json(await file.read())
       else:
           raise HTTPException(status_code=400, detail="Unsupported file format")

       # 一時的なシミュレーションとして保存
       simulation = create_temp_simulation(db)
       save_trades(simulation.id, trades, db)

       return {
           'success': True,
           'simulation_id': simulation.id,
           'trades_count': len(trades)
       }
   ```

**フロントエンド実装**:

1. **PerformanceAnalysisページの修正**:
   ```typescript
   // エクスポートボタン
   const handleExport = async (format: 'csv' | 'json') => {
     const response = await fetch(`/api/simulation/${simulationId}/export?format=${format}`)
     const blob = await response.blob()
     const url = window.URL.createObjectURL(blob)
     const a = document.createElement('a')
     a.href = url
     a.download = `trades_${new Date().toISOString()}.${format}`
     a.click()
   }

   // インポートボタン
   const handleImport = async (file: File) => {
     const formData = new FormData()
     formData.append('file', file)

     const response = await fetch('/api/simulation/import', {
       method: 'POST',
       body: formData
     })

     const data = await response.json()
     // インポート成功後、パフォーマンス分析画面に遷移
     navigate(`/performance/${data.simulation_id}`)
   }
   ```

#### 期待される効果

1. **売買履歴の永続化**:
   - トレード結果を保存して、後で見返すことができる
   - 長期的なトレードスキルの向上を追跡できる

2. **複数シミュレーションの比較**:
   - 異なる戦略の結果を比較できる
   - ベストプラクティスを見つけやすい

3. **ユーザー体験の向上**:
   - シミュレーションを再実行する必要がない
   - 過去のトレード結果を簡単に分析できる

#### 実装上の注意点

1. **データ整合性**:
   - インポートしたデータが正しい形式か検証
   - 必須フィールドが欠けていないかチェック

2. **セキュリティ**:
   - ファイルサイズの制限（例：10MB以下）
   - 悪意のあるファイルをアップロードできないようにする

#### テスト計画

1. **単体テスト**:
   - CSV/JSONのパース処理が正しく動作するか
   - エクスポートしたファイルが正しい形式か

2. **結合テスト**:
   - エクスポート → インポート → パフォーマンス分析の一連の流れが正しく動作するか

3. **UIテスト**:
   - エクスポートボタンをクリックするとファイルがダウンロードされるか
   - インポートボタンをクリックするとファイル選択ダイアログが表示されるか

---

### 9.8 F-005: AI（GPT-5.2）によるトレードフィードバック機能

#### 現状の問題点

**客観的なフィードバックの欠如**:
- 現在のパフォーマンス分析では、統計情報のみが表示される
- ユーザー自身でトレードの良し悪しを判断する必要がある
- プロのトレーダーの視点からのアドバイスが得られない
- 改善点が分かりにくい

**具体例**:
```
【現状】
- 勝率: 45%
- 総損益: -5,000円
- 最大ドローダウン: -10,000円
→ この数値を見ても、何が悪いのか、どう改善すればいいのか分からない

【期待されるフィードバック】
「勝率45%は一般的に低いですが、損益がマイナスなのは損大利小のトレードをしている可能性があります。
損切りラインを早めに設定し、利益確定を遅らせることで、損益比を改善できます。
また、最大ドローダウンが-10,000円と大きいため、リスク管理を見直すことをお勧めします。
1トレードあたりのリスクを資金の2%以下に抑えることを検討してください。」
```

#### 修正方針

**基本コンセプト**:
- OpenAI GPT-5.2 APIを利用して、売買履歴を分析
- プロのトレーダー視点でフィードバックを生成
- 改善点を具体的に提案
- ユーザーのトレードスキル向上をサポート

**修正対象**:

1. **OpenAI API連携**:
   - APIキー管理（環境変数またはユーザー設定）
   - GPT-5.2 APIの呼び出し
   - プロンプトエンジニアリング

2. **フィードバック表示**:
   - パフォーマンス分析画面に「AIフィードバック」セクションを追加
   - フィードバック生成ボタン
   - フィードバック結果の表示

3. **プロンプト設計**:
   - 売買履歴を構造化して送信
   - プロのトレーダーとしての役割を指示
   - 具体的な改善点を求める

#### 実装方針

**バックエンド実装**:

1. **OpenAI API連携サービス**:
   ```python
   # src/services/ai_feedback_service.py
   import openai
   from typing import List, Dict

   class AIFeedbackService:
       def __init__(self, api_key: str):
           openai.api_key = api_key

       def generate_feedback(self, trades: List[Dict], performance_stats: Dict) -> str:
           """
           売買履歴とパフォーマンス統計からフィードバックを生成
           """
           prompt = self._build_prompt(trades, performance_stats)

           response = openai.ChatCompletion.create(
               model="gpt-5-turbo",  # Note: GPT-5.2は仮の名前、実際のモデル名に置き換える
               messages=[
                   {
                       "role": "system",
                       "content": """あなたは経験豊富なプロのFXトレーダーです。
                       ユーザーの売買履歴を分析し、具体的で実践的なアドバイスを提供してください。
                       以下の点に注目して分析してください：
                       1. リスク管理（損切り、資金管理）
                       2. エントリー・イグジットのタイミング
                       3. 損益比（リスクリワード比）
                       4. トレード頻度
                       5. メンタル管理（連敗後の行動など）
                       6. トレンドフォローかレンジ相場か

                       フィードバックは以下の構成で提供してください：
                       1. 総合評価（良い点・悪い点）
                       2. 具体的な改善点（優先度順）
                       3. 次回のトレードで意識すべきこと
                       """
                   },
                   {
                       "role": "user",
                       "content": prompt
                   }
               ],
               temperature=0.7,
               max_tokens=2000
           )

           return response.choices[0].message.content

       def _build_prompt(self, trades: List[Dict], performance_stats: Dict) -> str:
           """
           売買履歴とパフォーマンス統計をプロンプトに整形
           """
           prompt = f"""
           以下の売買履歴とパフォーマンス統計を分析し、フィードバックを提供してください。

           【パフォーマンス統計】
           - 総トレード数: {performance_stats['total_trades']}
           - 勝トレード数: {performance_stats['win_trades']}
           - 負トレード数: {performance_stats['lose_trades']}
           - 勝率: {performance_stats['win_rate']:.2%}
           - 総損益: {performance_stats['total_profit']}円
           - 平均利益: {performance_stats['avg_profit']}円
           - 平均損失: {performance_stats['avg_loss']}円
           - 損益比: {performance_stats['profit_loss_ratio']:.2f}
           - 最大ドローダウン: {performance_stats['max_drawdown']}円
           - プロフィットファクター: {performance_stats['profit_factor']:.2f}

           【売買履歴】（最新10件）
           """

           for i, trade in enumerate(trades[-10:], 1):
               prompt += f"""
               {i}. {trade['type'].upper()} | エントリー: {trade['entry_time']} @ {trade['entry_price']} |
                  イグジット: {trade['exit_time']} @ {trade['exit_price']} |
                  損益: {trade['profit']}円 | 保有時間: {trade['hold_time']}秒
               """

           return prompt
   ```

2. **新しいAPIエンドポイント**:
   ```python
   @router.post("/simulation/{simulation_id}/ai-feedback")
   async def generate_ai_feedback(
       simulation_id: int,
       api_key: str = Header(..., alias="X-OpenAI-API-Key"),
       db: Session = Depends(get_db)
   ):
       """
       AIフィードバックを生成する
       """
       # 売買履歴とパフォーマンス統計を取得
       trades = get_trades(simulation_id, db)
       performance_stats = calculate_performance_stats(trades)

       # AIフィードバックを生成
       ai_service = AIFeedbackService(api_key)
       feedback = ai_service.generate_feedback(trades, performance_stats)

       return {
           'success': True,
           'feedback': feedback
       }
   ```

**フロントエンド実装**:

1. **PerformanceAnalysisページの修正**:
   ```typescript
   // AIフィードバック生成
   const [feedback, setFeedback] = useState<string | null>(null)
   const [isGenerating, setIsGenerating] = useState(false)

   const handleGenerateFeedback = async () => {
     setIsGenerating(true)
     try {
       // APIキーを取得（ユーザー設定から、または環境変数から）
       const apiKey = getOpenAIApiKey()

       const response = await fetch(`/api/simulation/${simulationId}/ai-feedback`, {
         method: 'POST',
         headers: {
           'X-OpenAI-API-Key': apiKey
         }
       })

       const data = await response.json()
       setFeedback(data.feedback)
     } catch (error) {
       console.error('Failed to generate AI feedback:', error)
       alert('AIフィードバックの生成に失敗しました。APIキーを確認してください。')
     } finally {
       setIsGenerating(false)
     }
   }

   // UIに追加
   <div className="ai-feedback-section">
     <h3>AIフィードバック</h3>
     <button onClick={handleGenerateFeedback} disabled={isGenerating}>
       {isGenerating ? '生成中...' : 'AIフィードバックを生成'}
     </button>
     {feedback && (
       <div className="feedback-content">
         <ReactMarkdown>{feedback}</ReactMarkdown>
       </div>
     )}
   </div>
   ```

2. **APIキー設定画面**:
   - 設定画面に「OpenAI APIキー」入力フィールドを追加
   - ローカルストレージまたはバックエンドに保存
   - セキュリティ: APIキーは暗号化して保存

#### 期待される効果

1. **客観的なフィードバック**:
   - プロのトレーダー視点からのアドバイスが得られる
   - 自分では気づけない改善点を発見できる

2. **トレードスキル向上への貢献**:
   - 具体的な改善点が提示される
   - 次回のトレードで意識すべきことが明確になる

3. **学習効率の向上**:
   - 試行錯誤の時間を短縮できる
   - 効率的にスキルアップできる

#### 実装上の注意点

1. **APIコスト**:
   - GPT-5.2（または GPT-4）の使用にはコストがかかる
   - ユーザーに明示的に了解を得る
   - 使用回数制限を設ける（オプション）

2. **APIキー管理**:
   - ユーザーが自分のAPIキーを設定できるようにする
   - または、アプリケーション側でAPIキーを管理し、使用量に応じて課金
   - セキュリティ: APIキーは暗号化して保存

3. **レート制限**:
   - OpenAI APIのレート制限に注意
   - 短時間に大量のリクエストを送らないようにする

4. **エラーハンドリング**:
   - APIキーが無効な場合のエラー処理
   - API呼び出しに失敗した場合のリトライ処理

5. **プライバシー**:
   - 売買履歴をOpenAIに送信することをユーザーに明示
   - プライバシーポリシーを確認

#### テスト計画

1. **単体テスト**:
   - プロンプト生成ロジックが正しく動作するか
   - OpenAI APIのモック応答を使用してテスト

2. **結合テスト**:
   - 実際のOpenAI APIを使用してフィードバックが生成されるか
   - APIキーが無効な場合にエラー処理が正しく動作するか

3. **UIテスト**:
   - フィードバック生成ボタンをクリックすると処理が開始されるか
   - 生成中の表示が正しく表示されるか
   - フィードバック結果が正しく表示されるか

#### 代替案

**注意**: 2026年2月時点で、OpenAI GPT-5.2は存在しない可能性があります。その場合、以下の代替案を検討してください：

1. **GPT-4 Turboを使用**:
   - モデル名: `gpt-4-turbo-preview` または最新のGPT-4モデル

2. **Claude 3.5 Sonnetを使用**:
   - Anthropic APIを使用
   - より詳細な分析が可能

3. **オープンソースLLMを使用**:
   - Llama 3, Mistral, Gemmaなど
   - セルフホスティングでコストを削減

実装時には、最新のLLMモデルとAPIの状況を確認してください。

---

## 10. 将来の拡張性
- リアルタイムデータとの連携（将来的に）
- 自動売買ロジックのバックテスト機能
- 複数の取引戦略のパフォーマンス比較
- モバイル対応
- 複数シミュレーション結果の比較分析（F-004の拡張）
- AIによる自動トレード戦略提案（F-005の拡張）
